<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Welcome to Boxik</title>
<script src="ui/jquery.js"></script>
<script src="ui/flot/jquery.flot.js"></script>
<script src="ui/flot/jquery.flot.time.min.js"></script>
<script src="ui/flot/jquery.flot.crosshair.js"></script>
<script src="ui/flot/jquery.flot.selection.js"></script>
<style type="text/css">
    .plotTitle{
	position: absolute;
	font-family: "lucida grande",tahoma,verdana,arial,sans-serif;
	letter-spacing: 1px;
	color:rgb(84, 84, 84);
        text-shadow:0 1px 0 rgba(0,0,0, 0.1); 
    }
    .card{
	border-radius: 10px;
	background-color: rgba( 255, 255, 255, 0.7 ); /* 0.5 with image*/
	position: absolute;
	width: 500px;
	height: 350px;
    }
    body{
	background-color: #f1f1f1;
	/*background-image: url("pics/bridge.jpg");*/
	background-repeat: no-repeat;
        background-attachment: fixed;
        background-position: center; 
    }
</style>
</head>
<body>
    <div id="graphing"></div>

<script>

var sizes = []; sizes.length = 0;
var twoRows = false;
var tiles = []; tiles.length = 0;
var colors =[ "#F7D842", "#F76D3C", "#F15F74", "#913CCD", 
	"#5481E6", "#839098", "#98CB4A", "#2CA8C2"];
var lastColorId = 0;
var standardLables = {
	    Temperature: ["Virtual Device", "Core 0", "Core 1"],
	    Processes: ["ps ax|wc -l"],
	    Load: [ "1min", "5min", "15min"],
	    Memory: [ "used %", "swap %"],
	    Packets: [ "br0", "nflog", "nfqueue", 
			"p1p1", "p2p1", "p4p1", 
			"p4p2", "p4p3", "any"]	
	};
    var numOfTiles = 5;

    //initiate Sizes ans Tiles
    initSizes();
    defineTiles();

    //initiate Flot 
    var tl = 0; // tile counter
    var tileW = tiles.shift();
    var tileH = tiles.shift();
    for( var p_id in standardLables ){
	var plotJQ = $( "<div></div>" ).appendTo( "#graphing" );
	plotJQ[0].id = p_id;
	var tileL = tiles[tl++], tileT = tiles[tl++];
	plotJQ.css({ "width":tileW, "height":tileH,
			"left": tileL, "top":tileT });

	var titleJQ = $( "<div>"+p_id+"</div>" ).appendTo( "#graphing" );
	titleJQ.addClass( "plotTitle" );
	titleJQ.css({ "left":tileL+sizes[6], "top":tileT+8 }); 

	plotJQ[0].options = {
            selection: { mode: "x", color:"#E52B50" },
            crosshair: { mode: "x" }, 
            grid:  {tickColor: "#c9d6de", borderWidth:0, 
		hoverable: true, autoHighlight: false }, 
            xaxis: { mode: "time", tickLength: 10 }, 
            yaxes: [{show:true, position:"right"}]
	};
	plotJQ.addClass( "card" );
	plotJQ.bind("plotselected", zoomIn);
	plotJQ.bind("plothover", debounce( 10, doCrosshair, false ) );
	getLog( p_id, plotSeries );
    }

    function doCrosshair(event, pos, item) {
	for( var p_id in standardLables ){
	    var flotO = $( "#"+p_id )[0].flot;
	    flotO.setCrosshair(pos);
	    updateLegend( p_id, flotO, pos );
	}
    }

    function updateLegend( id, flotO, pos ) {
        var legends = $("#"+id+" .legendLabel"); 
            
        var axes = flotO.getAxes();
        if (pos.x < axes.xaxis.min || pos.x > axes.xaxis.max) return;

        var dataset = flotO.getData();
            for ( var i = 0; i < dataset.length; ++i) {
                var series = dataset[i];

                // find the nearest points, x-wise
                for (var j = 0; j < series.data.length; ++j)
                    if (series.data[j][0] > pos.x)
                        break;
                var p1 = series.data[j - 1], p2 = series.data[j];
		var y = (p1 == null)? p2[1] : p1[1];

                legends.eq(i).text( series.label.replace(/=.*/, "= " + y ) );
            }
    }

    function zoomIn( event, ranges ) {
	var thisplot = this;
	var series = thisplot.flot.getData();
	var options = thisplot.flot.getOptions();

        // clamp the zooming to prevent eternal zoom
        if (ranges.xaxis.to - ranges.xaxis.from < 0.00001) {
		ranges.xaxis.to = ranges.xaxis.from + 0.00001;}
            
        // do the zooming
	for( var i=0; i<series.length; i++ ){
	    series[i].data = zoomInData( series[i].data, 
			ranges.xaxis.from,  ranges.xaxis.to );      
	}
        options=$.extend( true, {}, options, 
		{ xaxis: { min: ranges.xaxis.from, max: ranges.xaxis.to }});
        $.plot( $(thisplot), series, options);
    }

    function zoomInData(sourceData, x1, x2) { 
        var d = [];
        for (var i = 0; i <= sourceData.length-1; ++i) { 
            var x=sourceData[i][0];
            if(x1<=x && x<=x2) { d.push(sourceData[i]); }
        }
        return d;
    }

    function getLog( flotName, callbk ){
    	$.ajax({
	    whichFlot: flotName,
            url: "logs/"+flotName.toLowerCase(),
            method: 'GET',
            dataType: 'text', //because log file doesn't have .txt 
            success: callbk   //it gives stupid "syntax error" in firebug 
    	});
    }
    function plotSeries( datalog ){
	var plotId = this.whichFlot;
	var JQ = $( "#" + plotId );
	var series = textToSeries( datalog );
	for( var i=0; i < series.length; i++ ){
	   series[i] =  { color: colors[ lastColorId++ ], 
		label: standardLables[ plotId ][i]+" = 100000",  
                data: series[i], lines: { show: true }};
	}
	var flotObj = $.plot( JQ, series, JQ[0].options );
	JQ[0].flot = flotObj; // since I can't find how to call it
	//in the future, I maintain this reference
	fixLegendWidth( plotId );
    }
    function fixLegendWidth( id ){
       var legends = $("#"+id+" .legendLabel"); 
       legends.each( function (){ // fix the widths so they don't jump around
                $(this).css('width', $(this).width());
       });
    }
    function textToSeries( datalog ){
	// takes log file in format "time x0 x1 ... xN \n"
	// and converts into series N series for Flot
	// [[time0, x00], [time1, x01]...]
	// it assumes that data is sorted by time
	// otherwise add sortine
	var loglines = datalog.split( "\n" );
	loglines.pop();
	var series = []; series.length = 0;
	for( var i=0; i < loglines.length; i++ ){
	    var arr = loglines[i].split(/\s+/);
	    var linetime = Number(arr.shift())*1000;
	    for( var ii=0; ii < arr.length; ii++ ){
		arr[ii] = parseFloat( arr[ii] );
		if ( !isNaN(arr[ii]) ){ 
		    if( !$.isArray(series[ii])){
		       series[ii] = [ [linetime,arr[ii]] ];
		    }else{
		       series[ii].push( [linetime, arr[ii]] );
		    }
		}else{ arr.length = ii; }
			//because of whitespaces at the end
	    }
	}
    return series ;
    }

    function changeFontSizes(){
    }

    function defineTiles(){
	// each big tile has its W, H, X, Y
	// margins taken care of
	var W = $(window).width();
	if( twoRows ){
	   var margT = sizes[7];
	   var margS = sizes[8];
	   var between = sizes[6];
	   var tileW = W/2 - margS - between;
	   var tileH = tileW/1.618;
	   tiles.push( tileW );
	   tiles.push( tileH );
	   for( var i=0; i< numOfTiles; i++ ){
	     var ix = i%2;
	     var iy = (i-ix)/2
	     var L = margS + (tileW+between)*ix;
	     var T = margT + (tileH+between)*iy;
	   	tiles.push( L );
	   	tiles.push( T );
	   }
	}else{
	   var margT = sizes[7];
           var margS = sizes[9];
	   var between = margT;;
	   var tileW = W - 2*margS;
	   var tileH = tileW/1.618;
	   tiles.push( tileW );
	   tiles.push( tileH );
	   for( var i=0; i<numOfTiles; i++ ){
	       var T = margT + (tileH+between)*i;
	       tiles.push( margS );
               tiles.push( T );
	   }
	}
    }

    function initSizes(){
	var W = $(window).width(), 
	    H = $(window).height();
	twoRows = ( W > 1000 );
	//var metr = Math.min( W, H*1.618 );
	var metr = Math.max( W, 760 ); 
	sizes = [ metr ];
	while( metr > 1 ){ 
	    metr /= 1.618;
	    sizes.push( metr ); 
	} 
	sizes.reverse();
	console.log( W );
    }

function debounce(delay, callback) {
    var timeout = null;
    return function () {
        if (timeout) {clearTimeout(timeout);}
        var args = arguments;
        timeout = setTimeout(function () {
            callback.apply(null, args);
            timeout = null;
        }, delay);
    };
}

$(window).resize( debounce(250,  function (event) {
    initSizes();
    defineTiles();
}, false));

  </script>
</body>
</html>
